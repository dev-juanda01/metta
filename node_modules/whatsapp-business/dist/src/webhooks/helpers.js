"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWebhookController = exports.postWebhookController = exports.webhookHandler = void 0;
var webhookHandler = function (body, _a) {
    var _b;
    var onError = _a.onError, onMessageReceived = _a.onMessageReceived, onStatusReceived = _a.onStatusReceived, onTextMessageReceived = _a.onTextMessageReceived;
    (_b = body.entry) === null || _b === void 0 ? void 0 : _b.forEach(function (entry) {
        var _a;
        (_a = entry === null || entry === void 0 ? void 0 : entry.changes) === null || _a === void 0 ? void 0 : _a.forEach(function (change) {
            var _a, _b, _c, _d, _e, _f;
            //Generally, if not always, the message is just the index 0
            //But, since the docs don't say anything, we do it through a loop
            (_b = (_a = change === null || change === void 0 ? void 0 : change.value) === null || _a === void 0 ? void 0 : _a.messages) === null || _b === void 0 ? void 0 : _b.forEach(function (message) {
                var _a, _b, _c;
                //The contact is always the 0 and it is only received when there the messages field is present
                var contact = (_a = change === null || change === void 0 ? void 0 : change.value) === null || _a === void 0 ? void 0 : _a.contacts[0];
                //Call message event
                onMessageReceived && onMessageReceived(message, contact, (_b = change === null || change === void 0 ? void 0 : change.value) === null || _b === void 0 ? void 0 : _b.metadata);
                //If the message is type of text, then call the respective event
                if (message.type === "text" && message.text)
                    onTextMessageReceived &&
                        onTextMessageReceived({
                            id: message.id,
                            type: message.type,
                            text: message.text,
                            from: message.from,
                            timestamp: message.timestamp,
                        }, contact, (_c = change === null || change === void 0 ? void 0 : change.value) === null || _c === void 0 ? void 0 : _c.metadata);
            });
            //Call status event
            (_d = (_c = change === null || change === void 0 ? void 0 : change.value) === null || _c === void 0 ? void 0 : _c.statuses) === null || _d === void 0 ? void 0 : _d.forEach(function (status) {
                var _a;
                onStatusReceived && onStatusReceived(status, (_a = change === null || change === void 0 ? void 0 : change.value) === null || _a === void 0 ? void 0 : _a.metadata);
            });
            //Call error event
            (_f = (_e = change === null || change === void 0 ? void 0 : change.value) === null || _e === void 0 ? void 0 : _e.errors) === null || _f === void 0 ? void 0 : _f.forEach(function (err) { return onError && onError(err); });
        });
    });
};
exports.webhookHandler = webhookHandler;
var postWebhookController = function (events) { return function (req, res) {
    (0, exports.webhookHandler)(req.body, events);
    return res.send("success");
}; };
exports.postWebhookController = postWebhookController;
var getWebhookController = function (token) { return function (req, res) {
    if (req.query["hub.mode"] == "subscribe" && req.query["hub.verify_token"] == token) {
        try {
            return res.send(req.query["hub.challenge"]);
        }
        catch (err) {
            console.error("Could not subscribe to the webhook", "err: ".concat(JSON.stringify(err)));
        }
    }
    return res.sendStatus(400);
}; };
exports.getWebhookController = getWebhookController;
